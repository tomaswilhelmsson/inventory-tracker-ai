// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

// Unit entity
model Unit {
  id        Int       @id @default(autoincrement())
  name      String    @unique
  createdAt DateTime  @default(now())
  
  products  Product[]
  
  @@map("units")
}

// Supplier entity
model Supplier {
  id            Int              @id @default(autoincrement())
  name          String           @unique
  contactPerson String?
  email         String?
  phone         String?
  address       String?
  city          String?
  country       String?
  taxId         String?
  notes         String?
  createdAt     DateTime         @default(now())
  
  products        Product[]
  purchaseLots    PurchaseLot[]
  purchaseBatches PurchaseBatch[]
  
  @@map("suppliers")
}

// Product entity
model Product {
  id          Int       @id @default(autoincrement())
  name        String    @unique
  description String?
  unitId      Int
  supplierId  Int
  createdAt   DateTime  @default(now())
  
  unit        Unit      @relation(fields: [unitId], references: [id], onDelete: Restrict)
  supplier    Supplier  @relation(fields: [supplierId], references: [id], onDelete: Restrict)
  purchaseLots PurchaseLot[]
  yearEndCountItems YearEndCountItem[]
  
  // Performance indexes for frequently filtered queries
  @@index([supplierId])
  @@index([unitId])
  @@map("products")
}

// PurchaseBatch entity - groups lots from same invoice/delivery
model PurchaseBatch {
  id                 Int           @id @default(autoincrement())
  supplierId         Int
  purchaseDate       DateTime
  verificationNumber String?       // Invoice number
  invoiceTotal       Float         // Grand total including shipping
  shippingCost       Float         // Total shipping cost
  notes              String?       // Optional invoice notes
  createdAt          DateTime      @default(now())
  
  supplier      Supplier      @relation(fields: [supplierId], references: [id], onDelete: Restrict)
  purchaseLots  PurchaseLot[]
  
  @@map("purchase_batches")
}

// PurchaseLot entity - FIFO tracking
model PurchaseLot {
  id                Int            @id @default(autoincrement())
  
  // Foreign keys are nullable to preserve purchase history when products/suppliers
  // are deleted. Historical data is maintained in productSnapshot and supplierSnapshot
  // JSON fields, ensuring complete audit trail even after entity deletion.
  productId         Int?           // Foreign key for reference/filtering - nullable to allow deletion
  supplierId        Int?           // Foreign key for reference/filtering - nullable to allow deletion
  batchId           Int?           // Foreign key to PurchaseBatch (null for single-item purchases)
  
  purchaseDate      DateTime
  quantity          Int            // Original purchase quantity (never changes)
  unitCost          Float          // Cost per unit (includes shipping allocation if part of batch)
  remainingQuantity Int            // Current remaining quantity (decrements via FIFO)
  year              Int            // Extracted from purchaseDate
  verificationNumber String?       // Optional invoice/verification reference number
  
  // JSON snapshots - immutable transaction data (preserves data even if supplier/product deleted)
  productSnapshot   String         // JSON: {id, name, description, unit: {id, name}, supplierIdRef}
  supplierSnapshot  String         // JSON: {id, name, contactPerson, email, phone, address, city, country, taxId}
  
  createdAt         DateTime       @default(now())
  
  product     Product?        @relation(fields: [productId], references: [id], onDelete: SetNull)
  supplier    Supplier?       @relation(fields: [supplierId], references: [id], onDelete: SetNull)
  batch       PurchaseBatch?  @relation(fields: [batchId], references: [id], onDelete: SetNull)
  
  // CRITICAL: Index for FIFO ordering - MANDATORY for data integrity
  @@index([productId, purchaseDate, remainingQuantity], name: "fifo_index")
  @@index([batchId])
  @@map("purchase_lots")
}

// YearEndCount entity
model YearEndCount {
  id          Int       @id @default(autoincrement())
  year        Int
  revision    Int       @default(1)  // Tracks unlock/recount cycles
  status      String    @default("draft")  // draft | confirmed
  confirmedAt DateTime?
  backupPath  String?
  createdAt   DateTime  @default(now())
  
  items       YearEndCountItem[]
  
  @@unique([year, revision])
  // Performance indexes for frequently queried fields
  @@index([year])
  @@index([status])
  @@map("year_end_counts")
}

// YearEndCountItem entity
model YearEndCountItem {
  id                Int      @id @default(autoincrement())
  yearEndCountId    Int
  productId         Int
  expectedQuantity  Int
  countedQuantity   Int?
  variance          Int?
  value             Float?
  createdAt         DateTime @default(now())
  
  // CASCADE DELETE WARNING: When a YearEndCount is deleted, all associated items
  // are automatically deleted. This is intentional for draft counts but should
  // be prevented at application level for confirmed counts to preserve audit trail.
  yearEndCount YearEndCount @relation(fields: [yearEndCountId], references: [id], onDelete: Cascade)
  product      Product      @relation(fields: [productId], references: [id], onDelete: Restrict)
  
  @@unique([yearEndCountId, productId])
  @@map("year_end_count_items")
}

// LockedYear entity - tracks which years are locked
model LockedYear {
  id        Int      @id @default(autoincrement())
  year      Int      @unique
  lockedAt  DateTime @default(now())
  
  @@map("locked_years")
}

// YearUnlockAudit entity - immutable audit trail of year unlocks
model YearUnlockAudit {
  id              Int      @id @default(autoincrement())
  year            Int
  unlockedAt      DateTime @default(now())
  reasonCategory  String   // data_error | recount_required | audit_adjustment | other
  description     String   // Free-form explanation
  
  @@map("year_unlock_audits")
}

// User entity for authentication
model User {
  id           Int      @id @default(autoincrement())
  username     String   @unique
  passwordHash String
  createdAt    DateTime @default(now())
  
  @@map("users")
}
